#include "TimedRun.h"


void UI::drawSubtitle(const char *text) {
#ifdef PORTRAIT_DISPLAY
    UI::u8g.setFont(UI::FONT_SMALL);
    const char x = UI::DISPLAY_WIDTH - 1;
    const char y = UI::DISPLAY_HEIGHT - UI::BORDER_WIDTH - 1;
    UI::u8g.drawStr270(x, y, text);
#else
    u8g.setFont(FONT_REGULAR);
    u8g.drawStr(LINE_HEIGHT * 2, LINE_HEIGHT, text);
#endif
}

void UI::drawTitle(const char *title) {
    u8g.setFont(FONT_REGULAR);
#ifdef PORTRAIT_DISPLAY
    UI::u8g.drawStr(0, UI::LINE_HEIGHT, title);
#else
    u8g.drawStr270(LINE_HEIGHT, DISPLAY_HEIGHT - 1, title);
#endif

#ifdef DEBUG
    //Memory display
//    UI::u8g.setFont(u8g_font_u8glib_4);
    char mem_str[5];

    extern int __heap_start, *__brkval;
    int v;
    const int mem = (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
    Serial.begin(9600);
    Serial.println(mem);
    Serial.flush();
//    sprintf(mem_str, "%i", mem);
//    UI::u8g.drawStr(20, 20, mem_str);
#endif
}

void UI::drawTimeLine(char line, const int data, unsigned char y, unsigned char x, bool grams,
                      const bool small, bool selected, bool editor) {
    char c_t[6] = "";
    const bool weightLine = line == -1;

    if (small)
        u8g.setFont(FONT_SMALL);
    else
        u8g.setFont(FONT_REGULAR);

    if (!weightLine)
        drawSymbol(x, y, line, small ? SMALL_LINE_HEIGHT : LINE_HEIGHT);

#ifdef PORTRAIT_DISPLAY
    const unsigned char line_w = UI::DISPLAY_WIDTH;
#else
    const unsigned char line_w = DISPLAY_HEIGHT;
#endif

    //Seconds

    u8g.setColorIndex(1);
    const bool special_line = line != -1 && data == Mode::SPECIAL_DATA;
    const char *text = special_line ?
                       (line == 2 ? SPECIAL_TIME_HOLD_NAME : SPECIAL_TIME_START_NAME)
                                    : (weightLine ? "s/g" : (grams ? "g" : "s"));


    //Maybe one should use consts on that?
    u8g.setFont(FONT_SMALL);
    const unsigned char text_w = u8g.getStrWidth(text);
    const unsigned char text_x = special_line ? (x + 2 * LINE_HEIGHT + 2 * BORDER_WIDTH) : (x + line_w - text_w);
    u8g.drawStr(text_x, y - (special_line ? 1 : 0), text);

    //draw time
    if (!special_line) {
        if (!small)
            u8g.setFont(FONT_NUMERIC);

        printData(c_t, data, weightLine);

        const unsigned char data_w = u8g.getStrWidth(c_t);
        const unsigned char data_x = text_x - data_w;

        u8g.drawStr(data_x, y, c_t);
        if (selected && editor)
            u8g.drawHLine(data_x, y + BORDER_WIDTH, data_w);
    } else {
        if (selected && editor)
            u8g.drawHLine(text_x, y + BORDER_WIDTH, text_w);
    }

    if (selected && !editor) {
#if defined(MILL_BUTTON) && !defined(PORTRAIT_DISPLAY)
        const unsigned char d = BORDER_WIDTH;
#else
        const unsigned char d = UI::BORDER_WIDTH * 2;
#endif
        u8g.drawHLine(x, y + d, line_w);
    }
}

void UI::printData(char *c_t, const int data, const bool weightLine) {
    if (weightLine) {
        if (data < 1000)
            sprintf(c_t, "%i.%02i", data / 100, data % 100);
        else
            sprintf(c_t, "%i.%i", data / 100, data / 10 % 10);
    } else {
        if (data < 1000)
            sprintf(c_t, "%i.%i", data / 10, data % 10);
        else
            sprintf(c_t, "%i", data / 10);
    }
}

void UI::drawDirectionSymbol(const unsigned char x, const unsigned char y, const unsigned char height,
                             const bool back, const unsigned char weight) {
    const unsigned char h = height - 2 * BORDER_WIDTH;
    const unsigned char w0 = back ? (h / 2) : 0;
    const unsigned char w1 = back ? 0 : (h / 2);
    const unsigned char w = h / 2;
    const unsigned char x0 = x - h / 4 - weight * BORDER_WIDTH;
    const unsigned char y0 = y - BORDER_WIDTH;
    for (unsigned char l = 0; l < 2; l++) {
        for (unsigned char c = 0; c < BORDER_WIDTH * weight; c++) {
            const unsigned char x1 = x0 + c + l * (BORDER_WIDTH * weight * 2);
            u8g.drawLine(x1 + w0, y0, x1 + w1, y0 - w);
            u8g.drawLine(x1 + w0, y0 - h, x1 + w1, y0 - w);
        }
    }
}

void UI::drawSymbol(const unsigned char x, const unsigned char y, const unsigned char symbol,
                    const unsigned char line_height, const unsigned char border, const unsigned char weight) {
    u8g.setColorIndex(1);

    const unsigned char r = (line_height / 2) + border;
    u8g.drawDisc(x + r, y - (line_height / 2), r);

    u8g.setColorIndex(0);
    if (symbol < 2) {
        const char *s = symbol ? "2" : "1";
        u8g.drawStr(x + r - (u8g.getStrWidth(s) / 2) + (line_height < 18 ? 1 : 0), y, s);
    } else {
        drawDirectionSymbol(x + r, y, line_height, false, weight);
    }
    u8g.setColorIndex(1);
}

void UI::drawLargeSymbol(const unsigned char x, const unsigned char y, const unsigned char symbol) {
#ifdef MODE_SYMBOLS
    SYMBOLS[symbol].draw(&u8g, x, y - UI::LARGE_LINE_HEIGHT / 2);
#else
    drawSymbol(x, y, symbol, UI::LARGE_LINE_HEIGHT, 4, 2);
#endif

}

void UI::drawRunWeight(const unsigned char x, const unsigned char y, int weight, bool small, unsigned char line) {

    char c_t[6] = "";
    if (weight < 1000)
        sprintf(c_t, "%i.%i", weight / 10, weight % 10);
    else
        sprintf(c_t, "%i", weight / 10);

    u8g.setFont(small ? UI::FONT_REGULAR : FONT_LARGE_NUMERIC);
    u8g.drawStr(x - u8g.getStrWidth(c_t), y, c_t);

    if (line) {
        const char w = UI::u8g.getStrWidth(c_t);

        if (line == 1)
            UI::u8g.drawHLine(x - w, y + UI::BORDER_WIDTH, w);
        else
            UI::u8g.drawHLine(x - w, y + UI::BORDER_WIDTH, w + UI::SMALL_LINE_HEIGHT);
    }

    u8g.setFont(FONT_REGULAR);
    u8g.drawStr(x, y, "g");
}

void UI::drawRunTime(const unsigned char x, const unsigned char y, int seconds, bool small) {
    char c_t[6] = "";
    sprintf(c_t, "%i", seconds);
    u8g.setFont(small ? UI::FONT_REGULAR : FONT_LARGE_NUMERIC);
    u8g.drawStr(x - u8g.getStrWidth(c_t), y, c_t);

    u8g.setFont(FONT_REGULAR);
    u8g.drawStr(x, y, "s");
}

void UI::drawEditPoint(const unsigned char p, const bool active, const unsigned char symbol) {
//    UI::u8g.setFont(UI::FONT_SMALL);
#ifdef PORTRAIT_DISPLAY
    char c[2];
    c[0] = UI::MOVE_RIGHT_STRING;
    c[1] = 0;
    const unsigned char x =
            (DISPLAY_WIDTH / 6) * p + (p > 0 ? ((DISPLAY_WIDTH / 6) - u8g.getStrWidth(c)) : 0);
    const unsigned char y = DISPLAY_HEIGHT - 2 * BORDER_WIDTH;
#else
    const unsigned char x = UI::DISPLAY_WIDTH - (p == 0 ? (2 * UI::SMALL_LINE_HEIGHT + UI::BORDER_WIDTH * 4) :
                                       (UI::SMALL_LINE_HEIGHT + UI::BORDER_WIDTH * 2));
    const unsigned char y = p > 1 ? ((p - 1) * (UI::DISPLAY_HEIGHT - 2 * UI::SMALL_LINE_HEIGHT - 2 * UI::BORDER_WIDTH - 1) / 3 +
                           UI::SMALL_LINE_HEIGHT) : UI::SMALL_LINE_HEIGHT;
#endif

    char s[2];
    s[0] = symbol;
    s[1] = 0;
    u8g.drawStr(x, y, s);

    if (active) {
        u8g.drawHLine(x, (u8g_uint_t) (y + 1), u8g.getStrWidth(s));
    }
}

void UI::drawProgressBar(const double progress) {
#ifdef PORTRAIT_DISPLAY
    const unsigned char w = UI::DISPLAY_WIDTH * progress;
    u8g.drawBox(0, UI::DISPLAY_HEIGHT - UI::BORDER_WIDTH * 2 - 1, w, UI::BORDER_WIDTH * 2);
#else
    const unsigned char w = (UI::DISPLAY_WIDTH - UI::LINE_HEIGHT * 2) * progress;
    u8g.drawBox(UI::LINE_HEIGHT * 2, UI::DISPLAY_HEIGHT - UI::BORDER_WIDTH * 2 - 1, w, UI::BORDER_WIDTH * 2);
#endif
}

void UI::drawRunWeightLine(long weight, const unsigned char line) {
    weight = max(0, min(9999, weight));

#ifdef PORTRAIT_DISPLAY
    const char x = UI::DISPLAY_WIDTH - UI::SMALL_LINE_HEIGHT - UI::LINE_HEIGHT - UI::BORDER_WIDTH;
    const char y = UI::DISPLAY_HEIGHT - 2 * UI::SMALL_LINE_HEIGHT - 1;
    drawRunWeight(x, y, weight, true, line);
#else
    const char x = UI::DISPLAY_WIDTH - UI::LINE_HEIGHT - 1; //89
    const char y = UI::DISPLAY_HEIGHT - 3 * UI::BORDER_WIDTH - 1;//57;
    drawRunWeight(x, y, weight, false, line);
#endif
}


//------------------------------------------
// Symbols

void Symbol::draw(U8GLIB *_display, const unsigned char x, const unsigned char y) {
    for (unsigned char m = 0; m < multiple; m++)
        _display->drawXBMP((u8g_uint_t) (x + m * (width + 2 * UI::BORDER_WIDTH)), (u8g_uint_t) (y - (height / 2)),
                           width, height,
                           bits);
}


#ifdef BREW_BUTTON

#ifdef DISPLAY_128x64
static const u8g_pgm_uint8_t BREW_BITS[] U8G_PROGMEM = {
            0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00,
            0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00,
            0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
            0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x8f, 0x3f,
            0xff, 0xff, 0xff, 0xff, 0x0f, 0x7c, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x7c,
            0xfe, 0xff, 0xff, 0xff, 0x0f, 0x78, 0xfe, 0xff, 0xff, 0xff, 0x0f, 0x78,
            0xfe, 0xff, 0xff, 0xff, 0x0f, 0x78, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x7c,
            0xfe, 0xff, 0xff, 0xff, 0x07, 0x3c, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x3e,
            0xfe, 0xff, 0xff, 0xff, 0x07, 0x3e, 0xfc, 0xff, 0xff, 0xff, 0x07, 0x1f,
            0xfc, 0xff, 0xff, 0xff, 0x87, 0x0f, 0xfc, 0xff, 0xff, 0xff, 0xc7, 0x0f,
            0xfc, 0xff, 0xff, 0xff, 0xe3, 0x07, 0xf8, 0xff, 0xff, 0xff, 0xf3, 0x03,
            0xf8, 0xff, 0xff, 0xff, 0xfb, 0x01, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x00,
            0xf8, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0x00,
            0xf0, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x07, 0x00,
            0xf0, 0xff, 0xff, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x00, 0x00,
            0xe0, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x7f, 0x00, 0x00,
            0xc0, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0x00,
            0x80, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x00,
            0x00, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00
    };
    Symbol UI::BREW_SYMBOL(47, 40, BREW_BITS);
#else
static const u8g_pgm_uint8_t BREW_BITS[] U8G_PROGMEM = {
        0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x07, 0xff, 0xff, 0x07,
        0xff, 0xff, 0x07, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3,
        0xff, 0xff, 0xc3, 0xff, 0xff, 0xc3, 0xfe, 0xff, 0xe3, 0xfe, 0xff, 0x63,
        0xfe, 0xff, 0x73, 0xfe, 0xff, 0x39, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 0x07,
        0xfc, 0xff, 0x03, 0xfc, 0xff, 0x01, 0xf8, 0xff, 0x00, 0xf8, 0x7f, 0x00,
        0xf0, 0x7f, 0x00, 0xf0, 0x3f, 0x00
};
Symbol UI::BREW_SYMBOL(24, 30, BREW_BITS);
#endif
#endif


#ifdef MODE_SYMBOLS
//Converted with GIMP

//Large Symbols not used for now
#ifdef LARGE_SYMBOLS
static const u8g_pgm_uint8_t HAND_BITS[] U8G_PROGMEM = {
   0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0xff,
   0xff, 0x01, 0x00, 0x80, 0x1f, 0xf0, 0x07, 0x00, 0xe0, 0x07, 0xc0, 0x0f,
   0x00, 0xe0, 0x01, 0x00, 0x1f, 0x00, 0xf0, 0x00, 0x00, 0x3e, 0x00, 0x78,
   0x00, 0x00, 0x3c, 0x00, 0x3c, 0x00, 0x00, 0x78, 0x00, 0x3c, 0x00, 0x00,
   0x70, 0x00, 0x1e, 0x00, 0x00, 0xf0, 0x00, 0x0e, 0x00, 0x00, 0xe0, 0x00,
   0x0e, 0x00, 0x00, 0xe0, 0x01, 0x0e, 0x80, 0x03, 0xc0, 0x01, 0x0f, 0xc0,
   0x07, 0xc0, 0x01, 0x07, 0xc0, 0x07, 0xc0, 0x01, 0x07, 0xe0, 0x0f, 0xc0,
   0x01, 0x07, 0xe0, 0x0f, 0xc0, 0x01, 0x0e, 0xe0, 0x0f, 0xc0, 0x01, 0x0e,
   0xe0, 0x0f, 0xc0, 0x01, 0x0e, 0xe0, 0x0f, 0xe0, 0x00, 0x0e, 0xe0, 0x0f,
   0xe0, 0x00, 0x1e, 0xe0, 0x0f, 0xf0, 0x00, 0x1c, 0xe0, 0x0f, 0x00, 0x00,
   0x3c, 0xe0, 0x0f, 0x00, 0x00, 0x78, 0xe0, 0x0f, 0x00, 0x00, 0xf0, 0xe0,
   0x4f, 0x00, 0x00, 0xf0, 0xe1, 0xef, 0x01, 0x00, 0xe0, 0xe3, 0xff, 0x03,
   0x00, 0x80, 0xe3, 0xff, 0x03, 0x00, 0x00, 0xe3, 0xff, 0xf7, 0x00, 0x00,
   0xe0, 0xff, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0x01, 0x00, 0xe0, 0xff,
   0xff, 0x39, 0x00, 0xe0, 0xff, 0xff, 0x7d, 0x00, 0xe0, 0xff, 0xff, 0x7f,
   0x00, 0xe0, 0xff, 0xff, 0x7f, 0x00, 0xe0, 0xff, 0xff, 0x7f, 0xf0, 0xe0,
   0xff, 0xff, 0x7f, 0xf8, 0xe1, 0xff, 0xff, 0x7f, 0xf8, 0xe3, 0xff, 0xff,
   0x7f, 0xf8, 0xe7, 0xff, 0xff, 0x7f, 0xf8, 0xe7, 0xff, 0xff, 0x7f, 0xf0,
   0xef, 0xff, 0xff, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xff,
   0xff, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0x7f, 0x80, 0xff, 0xff, 0xff, 0x7f,
   0x00, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0xfc,
   0xff, 0xff, 0x7f, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0xe0, 0xff, 0xff,
   0x3f

};

static const u8g_pgm_uint8_t BEAN_BITS[] U8G_PROGMEM = {
   0x00, 0x00, 0xe0, 0xff, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00,
   0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0x0f, 0x00, 0xe0, 0xff, 0xff,
   0x01, 0x00, 0xf0, 0xff, 0x3f, 0x30, 0x00, 0xf8, 0xff, 0x0f, 0x3c, 0x00,
   0xfe, 0xff, 0x07, 0x7f, 0x00, 0xff, 0xff, 0xc1, 0x7f, 0x80, 0xff, 0xff,
   0xe0, 0x7f, 0x80, 0xff, 0x7f, 0xf0, 0x7f, 0xc0, 0xff, 0x3f, 0xf8, 0x7f,
   0xe0, 0xff, 0x1f, 0xfc, 0x7f, 0xf0, 0xff, 0x0f, 0xfe, 0x7f, 0xf0, 0xff,
   0x0f, 0xff, 0x7f, 0xf8, 0xff, 0x87, 0xff, 0x7f, 0xf8, 0xff, 0x87, 0xff,
   0x7f, 0xfc, 0xff, 0xc7, 0xff, 0x7f, 0xfc, 0xff, 0xc3, 0xff, 0x3f, 0xfe,
   0xff, 0xc3, 0xff, 0x3f, 0xfe, 0xff, 0xe3, 0xff, 0x3f, 0xfe, 0xff, 0xe1,
   0xff, 0x1f, 0xfe, 0xff, 0xe1, 0xff, 0x1f, 0xff, 0xff, 0xf0, 0xff, 0x0f,
   0xff, 0x7f, 0xf0, 0xff, 0x0f, 0xff, 0x7f, 0xf8, 0xff, 0x07, 0xff, 0x3f,
   0xfc, 0xff, 0x03, 0xff, 0x1f, 0xfc, 0xff, 0x03, 0xff, 0x0f, 0xff, 0xff,
   0x01, 0xff, 0x07, 0xff, 0xff, 0x00, 0xfe, 0xc1, 0xff, 0x7f, 0x00, 0xfe,
   0xe0, 0xff, 0x3f, 0x00, 0x3c, 0xfc, 0xff, 0x1f, 0x00, 0x0c, 0xfe, 0xff,
   0x0f, 0x00, 0xe0, 0xff, 0xff, 0x03, 0x00, 0xf0, 0xff, 0xff, 0x01, 0x00,
   0xe0, 0xff, 0x7f, 0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xff,
   0x03, 0x00, 0x00
};

Symbol UI::SYMBOLS[]{Symbol(39, 39, BEAN_BITS), Symbol(39, 39, BEAN_BITS, 2), Symbol(39, 53, HAND_BITS)};
#else
static const u8g_pgm_uint8_t HAND_BITS[] U8G_PROGMEM = {
        0x80, 0x07, 0x00, 0xf0, 0x1f, 0x00, 0x38, 0x70, 0x00, 0x0c, 0xe0, 0x00,
        0x06, 0x80, 0x01, 0x06, 0x80, 0x01, 0x02, 0x00, 0x03, 0x03, 0x03, 0x03,
        0x83, 0x07, 0x03, 0x82, 0x07, 0x03, 0x82, 0x07, 0x03, 0x82, 0x07, 0x01,
        0x86, 0x07, 0x00, 0x8c, 0x07, 0x00, 0x9c, 0x1f, 0x00, 0x90, 0x3f, 0x00,
        0x80, 0xff, 0x03, 0x80, 0xff, 0x0b, 0x80, 0xff, 0x1f, 0x80, 0xff, 0x1f
};

static const u8g_pgm_uint8_t BEAN_BITS[] U8G_PROGMEM = {
        0x00, 0xf8, 0x00, 0x00, 0xff, 0x03, 0x80, 0xff, 0x01, 0xc0, 0x3f, 0x06,
        0xf0, 0x9f, 0x0f, 0xf0, 0xcf, 0x0f, 0xf8, 0xe7, 0x0f, 0xfc, 0xf3, 0x0f,
        0xfc, 0xf3, 0x0f, 0xfe, 0xf9, 0x07, 0xfe, 0xf9, 0x07, 0xfe, 0xf9, 0x07,
        0xff, 0xfc, 0x03, 0x7f, 0xfe, 0x01, 0x3f, 0xff, 0x01, 0x9e, 0xff, 0x00,
        0xe6, 0x7f, 0x00, 0xf8, 0x1f, 0x00, 0xf8, 0x0f, 0x00, 0xf0, 0x01, 0x00
};

Symbol UI::SYMBOLS[]{Symbol(20, 20, BEAN_BITS), Symbol(20, 20, BEAN_BITS, 2), Symbol(21, 20, HAND_BITS)};

#endif

#endif


